// plugin.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "IPlugin.h"

#include <math.h>
#include <cmath>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>//to use cout

#include "colorspace.h"
#include "pyramid.h"
#include "smallKernels.h"


using namespace std;



////////////////////////////////////////////////////////////////////////
// A concrete plugin implementation
////////////////////////////////////////////////////////////////////////

// Photo-Reactor Plugin class

//****************************************************************************
//This code has been generated by the Mediachance photo reactor Code generator.


#define AddParameter(N,S,V,M1,M2,T,D) {strcpy (pParameters[N].m_sLabel,S);pParameters[N].m_dValue = V;pParameters[N].m_dMin = M1;pParameters[N].m_dMax = M2;pParameters[N].m_nType = T;pParameters[N].m_dSpecialValue = D;}

#define GetValue(N) (pParameters[N].m_dValue)
#define GetValueY(N) (pParameters[N].m_dSpecialValue)

#define SetValue(N,V) {pParameters[N].m_dValue = V;}

#define GetBOOLValue(N) ((BOOL)(pParameters[N].m_dValue==pParameters[N].m_dMax))

// if it is not defined, then here it is
//#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))

#define PARAM_LEVEL	0
#define PARAM_TYPE	1

#define NUMBER_OF_USER_PARAMS 2

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))


class Plugin1 : public IPlugin	
{
public:

	int fullimagewidth;
	int fullimageheight;
	int previewwidth;
	int previewheight;
		//Plugin Icon:
	//you can add your own icon by creating 160x100 png file, naming it the same as plugin dll and then placing it in the plugins folder
	//otherwise a generic icon will be use


	//this is the title of the box in workspace. it should be short
	const char* GetTitle () const
	{
		return "! Reduce";
	}
	
	// this will appear in the help pane, you can put your credits and short info
	const char* GetDescription () const
	{
		return "Gaussian Reduce and laplacian";
	}

	// BASIC PARAMETERS
	// number of inputs 0,1 or 2
	int GetInputNumber ()
	{
		return 1;
	}

	// number of outputs 0 or 1
	int GetOutputNumber ()
	{
		return 1;
	}

	int GetBoxColor ()
	{
		return RGB(44,78,119);
	}

	int GetTextColor ()
	{
		return RGB(165,236,255);
	}

	// width of the box in the workspace
	// valid are between 50 and 100
	int GetBoxWidth ()
	{
		return 80;
	}

	// set the flags
	// see the interface builder
	// ex: nFlag = FLAG_FAST_PROCESS | FLAG_HELPER;

	//FLAG_NONE same as zero	Default, no other flags set
	//FLAG_UPDATE_IMMEDIATELY	It is very fast process that can update immediately. When user turns the sliders on UI the left display will update
	//							Use Update Immediately only for fast and single loop processes, for example Desaturate, Levels.
	//FLAG_HELPER				It is an helper object. Helper objects will remain visible in Devices and they can react to mouse messages. Example: Knob, Monitor, Bridge Pin
	//FLAG_BINDING				Binding object, attach to other objects and can change its binding value. It never goes to Process_Data functions.  Example: Knob, Switch, Slider
	//FLAG_DUMMY				It is only for interface but never process any data. Never goes to Process_Data functions. Example: Text note
	//FLAG_SKIPFINAL			Process data only during designing, doesn't process during final export. Example: Monitor, Vectorscope 
	//FLAG_LONGPROCESS			Process that takes > 1s to finish. Long Process will display the Progress dialog and will prevent user from changing values during the process.
	//FLAG_NEEDSIZEDATA		    Process need to know size of original image, the zoom and what part of image is visible in the preview. When set the plugin will receive SetSizeData
	//FLAG_NEEDMOUSE			Process will receive Mouse respond data from the workplace. This is only if your object is interactive, for example Knob, Slider

	int GetFlags ()
	{
		// it is fast process
		int nFlag = FLAG_UPDATE_IMMEDIATELY | FLAG_NEEDSIZEDATA;
		
		return nFlag;
	}


	// User Interface Build
	// there is maximum 29 Parameters

	int GetUIParameters (UIParameters* pParameters)
	{

		// label, value, min, max, type_of_control, special_value
		// use the UI builder in the software to generate this

		AddParameter( PARAM_LEVEL ,"Level 0|Level 1|Level 2|Level 3|Level 4|Level 5", 1, 0, 5, TYPE_ONEOFMANY, 0);

		AddParameter( PARAM_TYPE ,"Gaussian|LaPlacian", 0, 0, 1, TYPE_ONEOFMANY, 0);


		return NUMBER_OF_USER_PARAMS;
	}
	


	// Actual processing function for 1 input
	//***************************************************************************************************
	// Both buffers are the same size
	// don't change the IN buffer or things will go bad for other objects in random fashion
	// the pBGRA_out comes already with pre-copied data from pBGRA_in
	// Note: Don't assume the nWidth and nHeight will be every run the same or that it contains the whole image!!!! 
	// This function receives buffer of the actual preview (it can be just a crop of image when zoomed in) and during the final calculation of the full buffer
	// this is where the image processing happens
	virtual void Process_Data (BYTE* pBGRA_out,BYTE* pBGRA_in, int nWidth, int nHeight, UIParameters* pParameters)
	{
		char sBuffer6[400];

		//List of Parameters
		BYTE type = (int)GetValue(PARAM_TYPE);

		BYTE level = (int)GetValue(PARAM_LEVEL);

		float colorDepth = 255.0;

		//We don't want an image too small for our pyramids
		if ((nWidth < 8) || (nHeight < 8))
		{
			sprintf(sBuffer6,"ERROR\nImage too Small\nTry a larger image!");MessageBox(NULL,sBuffer6,"stop", MB_OK);
			return;
		}

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//            HERE we are defining the Pyramid levels that we want to use                                  //
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////

		/////////////////////////// LEVEL 0		
		//resize first pyramid level to the nearest power of 2
		int pyramidWidthLevel0 = powerOfTwo(nWidth);
		int pyramidHeightLevel0 = powerOfTwo(nHeight);

		/////////////////////////// LEVEL 1
		//level 1 is 1/2 the size of level 0
		int pyramidWidthLevel1 = pyramidWidthLevel0 / 2;
		int pyramidHeightLevel1 = pyramidHeightLevel0 / 2;

		/////////////////////////// LEVEL 2
		//level 2 is 1/2 the size of level 1
		int pyramidWidthLevel2 = pyramidWidthLevel1 / 2;
		int pyramidHeightLevel2 = pyramidHeightLevel1 / 2;

		/////////////////////////// LEVEL 3
		//level 3 is 1/2 the size of level 2
		int pyramidWidthLevel3 = pyramidWidthLevel2 / 2;
		int pyramidHeightLevel3 = pyramidHeightLevel2 / 2;

		/////////////////////////// LEVEL 4
		//level 4 is 1/2 the size of level 3
		int pyramidWidthLevel4 = pyramidWidthLevel3 / 2;
		int pyramidHeightLevel4 = pyramidHeightLevel3 / 2;

		/////////////////////////// LEVEL 5
		//level 5 is 1/2 the size of level 4
		int pyramidWidthLevel5 = pyramidWidthLevel4 / 2;
		int pyramidHeightLevel5 = pyramidHeightLevel4 / 2;

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//            HERE we are defining the Pyramid levels that we want to use                                  //
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////


		int horizontalLevels = howManyLevelsCanBeProcessed(pyramidWidthLevel0,1);
		int verticalLevels = howManyLevelsCanBeProcessed(pyramidHeightLevel0,1);
		int numberOfPyramidLevels = min(horizontalLevels, verticalLevels);
		//adjust to 5 levels
		if (numberOfPyramidLevels < 5) 
		{
			sprintf(sBuffer6,"ERROR\nImage too Small\nTry a larger image!  Cannot create enough pyramid levels");MessageBox(NULL,sBuffer6,"stop", MB_OK);
			return;
		}


		int imagesize = nWidth * nHeight * 4;
		float* originalImage = new float[imagesize];
		initalizeArrayNeutralGrey(originalImage, nWidth, nHeight);


		//colorDepthReduce(originalImage, nWidth, nHeight);
		//place our image in a seperate array in the 0-1 range, where 0 is darkest and 1 is lightest
		for (int x = 0; x < nWidth; x++)
		{
			for (int y = 0; y < nHeight; y++)
			{
				int nIdx = x * 4 + y * 4 * nWidth;

				float red = pBGRA_in[nIdx + CHANNEL_R];
				float green = pBGRA_in[nIdx + CHANNEL_G];
				float blue = pBGRA_in[nIdx + CHANNEL_B];

				//originalImage[nIdx + CHANNEL_R] = red / colorDepth;
				//originalImage[nIdx + CHANNEL_G] = green / colorDepth;
				//originalImage[nIdx + CHANNEL_B] = blue / colorDepth;
				originalImage[nIdx + CHANNEL_R] = red;
				originalImage[nIdx + CHANNEL_G] = green;
				originalImage[nIdx + CHANNEL_B] = blue;
			}//end x
		}//end y



		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//            HERE we are defining the Pyramid level arrays that we want to use, this is a MEMORY HOG!!!!        //
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		
		/////////////////////////// LEVEL 0
		//
		float* pyramidLevel0Array = new float[pyramidWidthLevel0 * pyramidHeightLevel0 * 4];
		initalizeArrayNeutralGrey(pyramidLevel0Array, pyramidWidthLevel0, pyramidHeightLevel0);
		/////////////////////////// LEVEL 0


		copyImageToBottomPyramidLevel(originalImage, nWidth, nHeight, pyramidLevel0Array, pyramidWidthLevel0, pyramidHeightLevel0);
		

		/////////////////////////// LEVEL 1
		float* pyramidLevel1Array = new float[pyramidWidthLevel1 * pyramidHeightLevel1 * 4];
		initalizeArrayNeutralGrey(pyramidLevel1Array, pyramidWidthLevel1, pyramidHeightLevel1);
		/////////////////////////// LEVEL 1


		
		/////////////////////////// LEVEL 2
		float* pyramidLevel2Array = new float[pyramidWidthLevel2 * pyramidHeightLevel2 * 4];
		initalizeArrayNeutralGrey(pyramidLevel2Array, pyramidWidthLevel2, pyramidHeightLevel2);
		/////////////////////////// LEVEL 2

		/////////////////////////// LEVEL 3
		float* pyramidLevel3Array = new float[pyramidWidthLevel3 * pyramidHeightLevel3 * 4];
		initalizeArrayNeutralGrey(pyramidLevel3Array, pyramidWidthLevel3, pyramidHeightLevel3);
		/////////////////////////// LEVEL 3

		/////////////////////////// LEVEL 4
		float* pyramidLevel4Array = new float[pyramidWidthLevel4 * pyramidHeightLevel4 * 4];
		initalizeArrayNeutralGrey(pyramidLevel4Array, pyramidWidthLevel4, pyramidHeightLevel4);
		/////////////////////////// LEVEL 4

		/////////////////////////// LEVEL 5
		float* pyramidLevel5Array = new float[pyramidWidthLevel5 * pyramidHeightLevel5 * 4];
		initalizeArrayNeutralGrey(pyramidLevel5Array, pyramidWidthLevel5, pyramidHeightLevel5);
		/////////////////////////// LEVEL 5


		

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//            HERE we are defining the Pyramid level arrays that we want to use, this is a MEMORY HOG!!!!        //
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		

		if (level == 0)
		{
			//gaussianReducepyramid(pyramidLevel0Array, pyramidWidthLevel0, pyramidHeightLevel0, pyramidLevel1Array, pyramidWidthLevel1, pyramidHeightLevel1);
			//copyImageToOriginalSize(pyramidLevel0Array, pyramidWidthLevel0, pyramidHeightLevel0, originalImage, nWidth, nHeight);
		}

		

		if (level == 1)
		{
			initalizeArrayNeutralGrey(originalImage, nWidth, nHeight);
			gaussianReducepyramid(pyramidLevel0Array, pyramidWidthLevel0, pyramidHeightLevel0, pyramidLevel1Array, pyramidWidthLevel1, pyramidHeightLevel1);
			copyImageToOriginalSize(pyramidLevel1Array, pyramidWidthLevel1, pyramidHeightLevel1, originalImage, nWidth, nHeight);
		}

		if (level == 2)
		{
			initalizeArrayNeutralGrey(originalImage, nWidth, nHeight);
			gaussianReducepyramid(pyramidLevel0Array, pyramidWidthLevel0, pyramidHeightLevel0, pyramidLevel1Array, pyramidWidthLevel1, pyramidHeightLevel1);
			gaussianReducepyramid(pyramidLevel1Array, pyramidWidthLevel1, pyramidHeightLevel1, pyramidLevel2Array, pyramidWidthLevel2, pyramidHeightLevel2);
			copyImageToOriginalSize(pyramidLevel2Array, pyramidWidthLevel2, pyramidHeightLevel2, originalImage, nWidth, nHeight);
		}

		if (level == 3)
		{
			initalizeArrayNeutralGrey(originalImage, nWidth, nHeight);
			gaussianReducepyramid(pyramidLevel0Array, pyramidWidthLevel0, pyramidHeightLevel0, pyramidLevel1Array, pyramidWidthLevel1, pyramidHeightLevel1);
			gaussianReducepyramid(pyramidLevel1Array, pyramidWidthLevel1, pyramidHeightLevel1, pyramidLevel2Array, pyramidWidthLevel2, pyramidHeightLevel2);
			gaussianReducepyramid(pyramidLevel2Array, pyramidWidthLevel2, pyramidHeightLevel2, pyramidLevel3Array, pyramidWidthLevel3, pyramidHeightLevel3);

			copyImageToOriginalSize(pyramidLevel3Array, pyramidWidthLevel3, pyramidHeightLevel3, originalImage, nWidth, nHeight);
		}


		//test
		for (int x = 0; x < nWidth; x++)
		{
			for (int y = 0; y < nHeight; y++)
			{
				//int nIdx1 = x + y * nWidth;
				int nIdx1 = x * 4 + y * 4 * nWidth;

				//float nR = pyramidLevel0Array [nIdx1 + CHANNEL_R];
				//float nG = pyramidLevel0Array [nIdx1 + CHANNEL_G];
				//float nB = pyramidLevel0Array [nIdx1 + CHANNEL_B];

				float nR = originalImage [nIdx1 + CHANNEL_R];
				float nG = originalImage [nIdx1 + CHANNEL_G];
				float nB = originalImage [nIdx1 + CHANNEL_B];
				

				//float nR = pyramidLevel2Array [nIdx1 + CHANNEL_R];
				//float nG = pyramidLevel2Array [nIdx1 + CHANNEL_G];
				//float nB = pyramidLevel2Array [nIdx1 + CHANNEL_B];

				//pBGRA_out[nIdx1 + CHANNEL_R] = CLAMP255(nR * colorDepth);
				//pBGRA_out[nIdx1 + CHANNEL_G] = CLAMP255(nG * colorDepth);
				//pBGRA_out[nIdx1 + CHANNEL_B] = CLAMP255(nB * colorDepth);

				pBGRA_out[nIdx1 + CHANNEL_R] = CLAMP255(nR );
				pBGRA_out[nIdx1 + CHANNEL_G] = CLAMP255(nG );
				pBGRA_out[nIdx1 + CHANNEL_B] = CLAMP255(nB );
			}
		}
		//gaussianReducepyramid(pyramidLevel1Array,pyramidWidthLevel1,pyramidHeightLevel1,pyramidLevel2Array,pyramidWidthLevel2,pyramidHeightLevel2);
		//printArray(pyramidLevel2Array, pyramidWidthLevel2, pyramidHeightLevel2);
		/*
		gaussianReducepyramid(pyramidLevel2Array,pyramidWidthLevel2,pyramidHeightLevel2,pyramidLevel3Array,pyramidWidthLevel3,pyramidHeightLevel3);
		//printArray(pyramidLevel3Array, pyramidWidthLevel3, pyramidHeightLevel3);

		gaussianReducepyramid(pyramidLevel3Array,pyramidWidthLevel3,pyramidHeightLevel3,pyramidLevel4Array,pyramidWidthLevel4,pyramidHeightLevel4);
		//printArray(pyramidLevel4Array, pyramidWidthLevel4, pyramidHeightLevel4);

		//reduce actions

		sprintf(sBuffer6,"fullimagewidth = %d\n fullimageheight = %d\n\n nWidth = %d\n nHeight = %d\n\n\n pyramidWidthLevel0 = %d\n pyramidHeightLevel0 = %d\n\n pyramidWidthLevel1 = %d\n pyramidWidthLevel1 = %d"
			             ,fullimagewidth,       fullimageheight,         nWidth,       nHeight,           pyramidWidthLevel0,       pyramidHeightLevel0,         pyramidWidthLevel1,       pyramidHeightLevel1);
		MessageBox(NULL,sBuffer6,"Image Resolutions", MB_OK);
		

		//the pyramid level should now be found in pyramidLevel0Array

		*/

		//resizeImageOutput(pyramidLevel0Array, pyramidWidthLevel0, pyramidHeightLevel0, originalImage, nWidth, nHeight);

		
		//test
		for (int x = 0; x < nWidth; x++)
		{
			for (int y = 0; y < nHeight; y++)
			{
				//int nIdx1 = x + y * nWidth;
				int nIdx1 = x * 4 + y * 4 * nWidth;

				//float nR = pyramidLevel0Array [nIdx1 + CHANNEL_R];
				//float nG = pyramidLevel0Array [nIdx1 + CHANNEL_G];
				//float nB = pyramidLevel0Array [nIdx1 + CHANNEL_B];

				//float nR = originalImage [nIdx1 + CHANNEL_R];
				//float nG = originalImage [nIdx1 + CHANNEL_G];
				//float nB = originalImage [nIdx1 + CHANNEL_B];
				

				//float nR = pyramidLevel2Array [nIdx1 + CHANNEL_R];
				//float nG = pyramidLevel2Array [nIdx1 + CHANNEL_G];
				//float nB = pyramidLevel2Array [nIdx1 + CHANNEL_B];

				//pBGRA_out[nIdx1 + CHANNEL_R] = CLAMP255(nR * colorDepth);
				//pBGRA_out[nIdx1 + CHANNEL_G] = CLAMP255(nG * colorDepth);
				//pBGRA_out[nIdx1 + CHANNEL_B] = CLAMP255(nB * colorDepth);

				//pBGRA_out[nIdx1 + CHANNEL_R] = CLAMP255(nR );
				//pBGRA_out[nIdx1 + CHANNEL_G] = CLAMP255(nG );
				//pBGRA_out[nIdx1 + CHANNEL_B] = CLAMP255(nB );
			}
		}

		



#pragma endregion

		



		delete[] pyramidLevel0Array;
		delete[] pyramidLevel1Array;
		delete[] pyramidLevel2Array;
		delete[] pyramidLevel3Array;
		delete[] pyramidLevel4Array;
		delete[] pyramidLevel5Array;


		delete[] originalImage;




	}//end routine



						


	// actual processing function for 2 inputs
	//********************************************************************************
	// all buffers are the same size
	// don't change the IN buffers or things will go bad
	// the pBGRA_out comes already with copied data from pBGRA_in1
	virtual void Process_Data2 (BYTE* pBGRA_out, BYTE* pBGRA_in1, BYTE* pBGRA_in2, int nWidth, int nHeight, UIParameters* pParameters)
	{

	}







	//*****************Drawing functions for the BOX *********************************
	//how is the drawing handled
	//DRAW_AUTOMATICALLY	the main program will fully take care of this and draw a box, title, socket and thumbnail
	//DRAW_SIMPLE_A			will draw a box, title and sockets and call CustomDraw
	//DRAW_SIMPLE_B			will draw a box and sockets and call CustomDraw
	//DRAW_SOCKETSONLY      will call CustomDraw and then draw sockets on top of it
	
	// highlighting rectangle around is always drawn except for DRAW_SOCKETSONLY

	virtual int GetDrawingType ()
	{

		int nType = DRAW_AUTOMATICALLY;

		return nType;

	}


	// Custom Drawing
	// custom drawing function called when drawing type is different than DRAW_AUTOMATICALLY
	// it is not always in real pixels but scaled depending on where it is drawn
	// the scale could be from 1.0 to > 1.0
	// so you always multiply the position, sizes, font size, line width with the scale
	
	virtual void CustomDraw (HDC hDC, int nX,int nY, int nWidth, int nHeight, float scale, BOOL bIsHighlighted, UIParameters* pParameters)
	{
	}


	//************ Optional Functions *****************************************************************************************
	// those functions are not necessary for normal effect, they are mostly for special effects and objects


	// Called when FLAG_HELPER set. 
	// When UI data changed (user turned knob) this function will be called as soon as user finish channging the data
	// You will get the latest parameters and also which parameter changed
	// Normally for effects you don't have to do anything here because you will get the same parameters in the process function
	// It is only for helper objects that may not go to Process Data 
	BOOL UIParametersChanged (UIParameters* pParameters, int nParameter)
	{
		
		return FALSE;
	}

	// when button is pressed on UI, this function will be called with the parameter and sub button (for multi button line)
	BOOL UIButtonPushed (int nParam, int nSubButton, UIParameters* pParameters)
	{

		return TRUE;
	}


	// Called when FLAG_NEEDSIZEDATA set
	// Called before each calculation (Process_Data)
	// If your process depends on a position on a frame you may need the data to correctly display it because Process_Data receives only a preview crop
	// Most normal effects don't depend on the position in frame so you don't need the data
	// Example: drawing a circle at a certain position requires to know what is displayed in preview or the circle will be at the same size and position regardless of zoom
	
	// Note: Even if you need position but you don't want to mess with the crop data, just ignore it and pretend the Process_Data are always of full image (they are not). 
	// In worst case this affects only preview when using zoom. The full process image always sends the whole data

	// nOriginalW, nOriginalH - the size of the original - full image. If user sets Resize on input - this will be the resized image
	// nPreviewW, nPreviewH   - this is the currently processed preview width/height - it is the same that Process_Data will receive
	//                        - in full process the nPreviewW, nPreviewH is equal nOriginalW, nOriginalH
	// Crop X1,Y1,X2,Y2       - relative coordinates of preview crop rectangle in <0...1>, for full process they are 0,0,1,1 (full rectangle)	
	// dZoom                  - Zoom of the Preview, for full process the dZoom = 1.0
	void SetSizeData(int nOriginalW, int nOriginalH, int nPreviewW, int nPreviewH, double dCropX1, double dCropY1, double dCropX2, double dCropY2, double dZoom)
	{

		// so if you need the position and zoom, this is the place to get it.
		// Note: because of IBM wisdom the internal bitmaps are on PC always upside down, but the coordinates are not
		fullimagewidth = nOriginalW;
		fullimageheight = nOriginalH;
		previewwidth = nPreviewW;
		previewheight = nPreviewH;

	}


	// ***** Mouse handling on workplace *************************** 
	// only if FLAG_NEEDMOUSE is set
	//****************************************************************
	//this is for special objects that need to receive mouse, like a knob or slider on workplace
	// normally you use this for FLAG_BINDING objects

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonDown (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		
		// return FALSE if not handled
		// return TRUE if handled
		return FALSE;
	}

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseMove (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
	

		return FALSE;
	}
	
	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonUp (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		
		// Note: if we changed data and need to recalculate the flow we need to return TRUE

		// return FALSE if not handled
		// return TRUE if handled
		
		return TRUE;
	}


};

extern "C"
{
	// Plugin factory function
	__declspec(dllexport) IPlugin* Create_Plugin ()
	{
		//allocate a new object and return it
		return new Plugin1 ();
	}
	
	// Plugin cleanup function
	__declspec(dllexport) void Release_Plugin (IPlugin* p_plugin)
	{
		//we allocated in the factory with new, delete the passed object
		delete p_plugin;
	}
	
}


// this is the name that will appear in the object library
extern "C" __declspec(dllexport) char* GetPluginName()
{
	return "! A Pyramid";	
}


// This MUST be unique string for each plugin so we can save the data

extern "C" __declspec(dllexport) char* GetPluginID()
{
	return "com.lumafilters.pyramid";
}


// category of plugin, for now the EFFECT go to top library box, everything else goes to the middle library box
extern "C" __declspec(dllexport) int GetCategory()
{
	return CATEGORY_EFFECT;
}

